{
    "collab_server" : "",
    "contents" : "# Various tools for High-Dimensional cointegration simulation\n\n# Find the moment matrices for Johansens eigenvalue problem.\nSij <- function(Ri,Rj){\n  N = ncol(Ri)\n  Stmp = 0\n  for(t in 1:N) Stmp = Stmp+Ri[,t]%*%t(Rj[,t])/N\n  Stmp\n}\n\n\n# Get the eigenvalues of the combination of the moment matrices S00, S11, S01, S10\nSeigen <- function(X){\n  dX = diff(t(X))\n  X1 = t(X[,-N])\n\n  R0 = t(dX-apply(dX,2,sum)/N)\n  R1 = t(X1-apply(X1,2,sum)/N)\n\n  S00 = Sij(R0,R0)\n  S01 = Sij(R0,R1)\n  S10 = Sij(R1,R0)\n  S11 = Sij(R1,R1)\n  e = sort(eigen(S01%*%solve(S11)%*%S10%*%solve(S00))$values,decreasing = FALSE)\n  return(list(e=e,S00=S00,S01=S01,S11=S11))\n}\n\n\neigenTest <- function(vals){\n\n  n = length(vals)\n\n  if(vals[1] > vals[n])\n    vals = sort(vals,decreasing = FALSE)\n\n  test = cumsum(log(1-vals))\n\n  return(test)\n}\n\n\n\n\n\n# Tools for the package, tests and calcuations.\n\n# Find the p-values for the Johansen procedure using bootstrapped values\nrankTest <- function(M){\n  p = length(M$test)\n  pVals = numeric(0)\n  for(i in 1:p){\n    test.cdf = ecdf(M$boot[i,])\n    pVals[i] = 1-test.cdf(M$test[i])\n  }\n  names(pVals) = paste0(\"r=\",(0:(p-1)))\n  if(any(pVals>0.05)){\n    r.est = min(which(pVals>0.05))-1\n  } else{\n    r.est = p\n  }\n  names(r.est) = \"\"\n  out = list(r=r.est,pVal = pVals)\n  return(out)\n}\n\n\n# Test restrictions (using LRT) on alpha and beta, input models (from:unrestricted/previous, to:restrictions)\nLRtest <- function(from,to){\n  T     = nrow(from$res)+1\n  r     = to$r\n  df    = to$df\n  lp    = from$lambda\n  lh    = to$lambda\n  test  = T*sum(log(1-lh[1:r])-log(1-lp[1:r]))\n  pVal  = pchisq(test,df,lower.tail = FALSE)\n  out   = round(data.frame(test,df,pVal),3)\n  names(out) = c(\"Statistic\",\"df\",\"p-value\")\n  return(out)\n}\n\n\n# Caculate the standard errors for alpha and mu\ngetSE <- function(fit){\n  N   = fit$N\n  dt  = fit$dt\n  Om  = fit$Omega\n  phi = fit$data\n  r   = fit$r\n  p   = nrow(Om)\n\n  # Calculate...\n  if(r==0){\n    SE = sqrt(diag(Om)*dt)\n    alpha = NULL\n  } else {\n    alpha = fit$alpha\n    beta = fit$beta\n    #Z = t(beta)%*%t(phi)\n    Z = crossprod(beta,t(phi))\n    Z = rbind(Z,1)\n    #ZZ = solve(Z%*%t(Z))\n    ZZ = solve(tcrossprod(Z,Z))\n    SE = sqrt(diag(kronecker(Om,ZZ))/dt)\n  }\n\n  # Set output with headers\n  outMat = matrix(SE,nr=3,byrow=TRUE)\n  outVec = c(outMat)\n  rownames(outMat) = c(\"phi_1\",\"phi_2\",\"phi_3\")\n  if(r > 0){\n    colnames(outMat)=c(paste0(\"alpha_\",1:r),\"mu\")\n    names(outVec) = c(paste0(\"alpha_\",as.character(outer(10*(1:p),(1:r),FUN = \"+\"))),paste0(\"mu_\",1:p))\n  } else {\n    colnames(outMat)=paste0(\"mu\")\n    names(outVec)=paste0(\"mu_\",1:p)\n  }\n  out = rbind(c(alpha,fit$Psi),outVec)\n  tVal = abs(out[1,]/out[2,])\n  pVal = 2*pnorm(tVal,lower.tail = FALSE)\n  out = rbind(out,pVal)\n\n  colnames(out) = names(outVec)\n  rownames(out) = c(\"Estimate\",\"Std.Err\",\"p-value\")\n\n\n  # Tvals = abs(estPar)/stdErr\n  # pVals = 2*pnorm(Tvals,lower.tail = FALSE)\n  return(t(out))\n}\n\n\n\n\nKuramoto.alpha <- function(p,pvec,avec){\n  rvec=pvec-1\n  n = length(pvec)\n  aout = matrix(0,nr=p,nc=sum(rvec))\n  for(i in 1:n){\n    ai =  matrix(avec[i],nr=pvec[i],nc=rvec[i])\n    diag(ai) = -rvec[i]*avec[i]\n    if(i == 1 ){\n      aout[1:pvec[i],1:rvec[i]] = ai\n    } else{\n      aout[(sum(pvec[1:(i-1)])+1):sum(pvec[1:(i)]),(sum(rvec[1:(i-1)])+1):sum(rvec[1:(i)])] = ai\n    }\n  }\n  return(aout)\n}\n\n\nKuramoto.beta <- function(p,pvec,bvec){\n  rvec=pvec-1\n  n = length(pvec)\n  if(length(bvec)==1) bvec = rep(bvec,n)\n  bout = matrix(0,nr=p,nc=sum(rvec))\n  for(i in 1:n){\n    bi =  rbind(bvec[i]*diag(rvec[i]),rep(-bvec[i],rvec[i]))\n    if(i == 1 ){\n      bout[1:pvec[i],1:rvec[i]] = bi\n    } else{\n      bout[(sum(pvec[1:(i-1)])+1):sum(pvec[1:(i)]),(sum(rvec[1:(i-1)])+1):sum(rvec[1:(i)])] = bi\n    }\n  }\n  return(bout)\n}\n\n\n\n\ninner.product <- function(A,B){\n  if(is.vector(A)){\n    sum(A*B)\n  }else{\n    sum(diag(t(A)%*%B))\n  }\n  # sum(diag(Conj(t(A))%*%A))\n}\nmatrix_angle <- function(A,B) {\n  if(A==0 || B==0){\n    0\n  } else if(all(A==B)){\n    0\n  } else {\n    tmp = inner.product(A,B)/sqrt(inner.product(A,A)*inner.product(B,B))\n    tmp#sqrt(Re(tmp)^2+Im(tmp)^2)\n  }\n}\n\n\nfrobenius <- function(M){\n  sqrt(sum(M^2))\n}\nOm.hat <-function(X,P){\n  N   = ncol(X)\n  R0  = t(diff(t(X)))\n  R1  = X[,-N]\n  S00 = S(R0,R0)\n  S11 = S(R1,R1)\n  S01 = S(R0,R1)\n  S10 = S(R1,R0)\n  out = S00-P%*%S10-S01%*%P+P%*%S11%*%t(P)\n  return(out)\n}\n\nlogL <- function(X,P){\n  N   = ncol(X)\n  Om  = Om.hat(X,P)\n  -.5*N*log(det(Om))\n}\n\nlow_rank <- function(M,r){\n  # Low rank approximation of a matrix using the Eckart-Young-Mirsky theorem\n  svd(M)$u[,1:r]%*%diag(svd(M)$d[1:r])%*%t(svd(M)$v[,1:r])\n}\n\nsym_project <- function(M){\n  return(.5*(M+t(M)))\n}\n\nP.sym.hat <- function(X,r){\n  N   = ncol(X)\n  dX  = diff(t(X))\n  X1  = t(X[,-N])\n  R0  = t(dX)\n  R1  = t(X1)\n  S00 = S(R0,R0)\n  S01 = S(R0,R1)\n  S10 = S(R1,R0)\n  S11 = S(R1,R1)\n  M.tmp = S01%*%solve(S11)\n  tmp.sym = sym_project(M.tmp)\n  tmp.sym = low_rank(tmp.sym,r)\n  return(tmp.sym)\n}\n\n\ntest_matrix <- function(M,B, dec=4){\n  cat(\"\\nSymmetry of P.hat:                                     \", round(frobenius(M-t(M)), dec))\n  cat(\"\\nAngle between B and P.hat:                             \", round(acos(matrix_angle(B,M)), dec))\n  cat(\"\\nFrobenius norm of |B-P.hat|:                           \", round(frobenius(B-M), dec))\n  cat(\"\\nStandard deviation of P.hat (outside block structure): \", round(sd(M[B==0]), dec))\n}\n\n\n\nci.bounds <-function(x) quantile(x, probs=c(.025,.975))\n\nmake_ci <- function(M){\n  out = as.data.frame(t(apply(M,1,ci.bounds)))\n  names(out) <- c('lo', 'hi')\n  return(out)\n}\n",
    "created" : 1551191989732.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4080870069",
    "id" : "C2C8F743",
    "lastKnownWriteTime" : 1551257190,
    "last_content_update" : 1551257190570,
    "path" : "~/Library/Mobile Documents/com~apple~CloudDocs/GitHub/Source/R/High-Dim Cointegration/HiDimCI/R/tools.R",
    "project_path" : "R/tools.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}