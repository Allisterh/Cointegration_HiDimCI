{
    "collab_server" : "",
    "contents" : "// Perform Johansen procedure for alpha/beta-restricted VECM models.\n// Model is dX = (Pi*X[t-1]+Phi*D[t])dt + Sigma*dW[t], 3-dimensional... for now.\n\n// [[Rcpp::depends(RcppArmadillo)]]\n#include <RcppArmadillo.h>\n#include <stdio.h>\n#include <math.h>\n#include \"johaTools.h\"\n\nusing namespace Rcpp;\nusing namespace arma;\nusing namespace std;\n\n\narma::mat vecm(arma::mat X, int r, arma::mat A, arma::mat B, bool Psi, double dt){\n\n  /* Inputs:\n   *    X     Time series observations: dimensions should be p-by-N => each row is a marginal time-series\n   *    r     The rank to use for estimation of parameters\n   *    A,B   Restrictions for alpha/beta matrices. For no restrictions, input identity matrices.\n   *    dt    Time resolution.\n   */\n\n  // Overall properties of the system\n    int N = X.n_cols-1;   // Number of observations (-1 since we look at the differenced process)\n    int p = X.n_rows;     // Dimension of the system\n    int s = B.n_cols;     // Restrictions for beta matrix\n\n  // Find Z0, Z1 and Z2 for input data matrix X\n    mat Z0 = zeros<mat>(p,N);\n    mat Z1 = zeros<mat>(p,N);\n    for(int n=0;n<N;n++){\n      Z0.col(n) = X.col(n+1)-X.col(n);  // The differenced process dX[t] (calculated as X[t+1]-X[t])\n      Z1.col(n) = X.col(n);             // The lagged process X[t-1]\n    }\n    mat Z2 = ones<mat>(1,N);\n\n\n  // Find moment matrices M_{ij}\n    mat M22,M02,M12,M22_1;\n    M22   = M(Z2,Z2);\n    M02   = M(Z0,Z2);\n    M12   = M(Z1,Z2);\n    M22_1 = inv(M22);\n\n  // Find residuals R0,R1\n    mat R0,R1;\n    if(Psi){\n      R0 = Z0-M02*M22_1*Z2;\n      R1 = Z1-M12*M22_1*Z2;\n    } else{\n      R0 = Z0;\n      R1 = Z1;\n    }\n\n\n  // Find covariance matrices S_{ij}\n    mat S00,S11,S01,S10,S00_1, S10S00S01, S11_B;\n    S00 = S(R0,R0);\n    S11 = S(R1,R1);\n    S01 = S(R0,R1);\n    S10 = S(R1,R0);\n    S00_1 = inv(S00);\n\n\n  // For restricted A: correct residuals\n    mat Ap = M_perp(A);\n    mat Ab = M_bar(A);\n    mat Rt0,Rt1,St00,St11,St01,St10,St00_1;\n\n\n  // Find the matrix to solve for the eigenvalue problem\n    mat solveMat;\n\n  if(Ap.size() != 1){ // A.perp is not degenerate => correct for alpha restrictions\n    Rt0       = R0-S00*Ap*inv(Ap.t()*S00*Ap)*Ap.t()*R0;\n    Rt1       = R1-S10*Ap*inv(Ap.t()*S00*Ap)*Ap.t()*R0;\n    St00      = S(Rt0,Rt0);\n    St11      = S(Rt1,Rt1);\n    St01      = S(Rt0,Rt1);\n    St10      = S(Rt1,Rt0);\n    St00_1    = inv(Ab.t()*S00*Ab);\n    S10S00S01 = B.t()*St10*Ab*St00_1*Ab.t()*St01*B;\n\n  } else{ // Solve for the eigenvalues (and vectors) as usual (including beta restrictions)\n    St00      = S(R0,R0);\n    St11      = S(R1,R1);\n    St01      = S(R0,R1);\n    St10      = S(R1,R0);\n    St00_1    = inv(S00);\n    S10S00S01 = B.t()*S10*S00_1*S01*B;\n  }\n\n  // solveMat    = inv(B.t()*St11*B)*S10S00S01;\n  S11_B       = B.t()*St11*B;\n\n  // solve for eigenvalues\n    cx_vec eigval_cx;\n    cx_mat eigvec_cx;\n\n  // first for S11...\n    eig_gen(eigval_cx, eigvec_cx, S11_B);\n    // C++ function returns complex vectors/matrices, so extract real parts\n    vec p_val = real(eigval_cx);\n    mat W     = real(eigvec_cx);\n\n    // find decomposition of S11 from diagonalization\n    mat S11_5 = W*diagmat(1/sqrt(p_val))*W.t();\n\n  // then for S11_5...S11_5...\n    eig_gen(eigval_cx, eigvec_cx, S11_5*S10S00S01*S11_5);\n    // C++ function returns complex vectors/matrices, so extract real parts\n    vec l_val = real(eigval_cx);\n    mat U     = real(eigvec_cx);\n\n    // convert to the correct eigenvectors\n    mat V = S11_5*U;\n\n    // set the values into old placeholders\n    vec eigval = l_val;\n    mat eigvec = V;\n\n  // Sort by eigenvalues, descending (sort vectors first!)\n    eigvec = eigvec.cols(sort_index(eigval,\"descend\"));\n    eigval = eigval(sort_index(eigval,\"descend\"));\n\n\n\n\n  // Normalize eigenvectors\n    for(int i=0;i<s;i++){\n\n      if(Ap.size() != 1){ // A.perp is not degenerate!\n        double nf = as_scalar(sqrt(eigvec.col(i).t()*(B.t()*St11*B)*eigvec.col(i)));\n        eigvec.col(i) = eigvec.col(i)/sqrt(nf);\n      } else{\n        double nf = as_scalar(sqrt(eigvec.col(i).t()*(B.t()*S11*B)*eigvec.col(i)));\n        eigvec.col(i) = eigvec.col(i)/sqrt(nf);\n      }\n  }\n\n  // To use cumsum for the teststats, the eigenvalues must be sorted \"in reverse\", this is ascending...\n    vec testStat = -N*cumsum(log(1-eigval(sort_index(eigval,\"ascend\"))));\n    testStat = sort(testStat,\"descend\");\n\n  // Normalize beta with the identity matrix of size 'r' in the upper 'r' rows using c {p x r} = (I{r x r},0{()p-r) x r})\n    mat b_hat = B*eigvec.cols(0,r-1);\n    mat Ir = eye<mat>(r,r);\n    mat c = join_cols(Ir,zeros<mat>(p-r,r));\n    if(det(c.t()*b_hat)!=0){ // Normalize b_hat if possible...\n      b_hat = b_hat*inv(c.t()*b_hat);\n    }\n\n// mat b_print = b_hat.submat(0,0,6,6);\n// cout << round(100*b_print)/100 << endl;\n\n\n\n  // Find OLS estimates of alpha (loadings), psi (deterministic trends) and omega (covariance)\n    mat BS11B_1 = inv(b_hat.t()*S11*b_hat);\n    mat a_hat = A*Ab.t()*S01*b_hat*BS11B_1;\n    mat Psi_hat = (M02*M22_1-a_hat*b_hat.t()*M12*M22_1);\n    if(!Psi){\n      // Set estimate at 0 if not to be estimated...\n      Psi_hat = 0*Psi_hat;\n    }\n    mat Omega_hat = S00-S01*b_hat*BS11B_1*b_hat.t()*S10;\n\n  // Calculate residuals\n    mat Pi_hat = a_hat*b_hat.t();\n    mat res = zeros<mat>(p,N);\n    for(int n=0;n<N;n++){\n      res.col(n) = Z0.col(n)-Pi_hat*(Z1.col(n))-Psi_hat;\n    }\n\n  // Set the output with parameter estimates (alpha, beta, psi, omega), test statistics, eigenvalues and residuals\n    int outRows = p;\n    int outCols = a_hat.n_cols+b_hat.n_cols+1+p+2+N;\n    mat out = zeros<mat>(outRows,outCols);\n\n  // Insert alpha estimate in output\n    for(int i=0; i<a_hat.n_cols;i++){\n      out.col(i) = a_hat.col(i)/dt;\n    }\n\n  // Insert beta estimate in output\n    for(int i=0;i<b_hat.n_cols;i++){\n      int j = a_hat.n_cols;\n      out.col(j+i) = b_hat.col(i);\n    }\n\n  // Insert Psi estimate in output\n    int j = a_hat.n_cols+b_hat.n_cols;\n    out.col(j) = Psi_hat/dt;\n\n  // Insert Omega estimate in output\n    for(int i=0;i<p;i++){\n      j = a_hat.n_cols+b_hat.n_cols+1;\n      out.col(j+i) = Omega_hat.col(i)/dt;\n    }\n\n  // Insert test statistic in output, append zeros to match dimensions...\n    testStat = join_cols(testStat,zeros<mat>(p-s,1));\n    eigval = join_cols(eigval,zeros<mat>(p-s,1));\n\n    j = a_hat.n_cols+b_hat.n_cols+1+p;\n    out.col(j) = testStat;\n    j = a_hat.n_cols+b_hat.n_cols+1+p+1;\n    out.col(j) = eigval;\n\n  // Insert residuals in output\n    for(int i=0;i<N;i++){\n      j = a_hat.n_cols+b_hat.n_cols+1+p+2;\n      out.col(j+i) = res.col(i);\n    }\n  return out;\n}\n\n\n// Estimation for a VAR model when r=0...\narma::mat var(arma::mat X, bool Psi, double dt){\n\n  /* Inputs:\n   *    X     Time series observations: dimensions should be p-by-N => each row is a marginal time-series\n   *    dt    Time resolution.\n   */\n\n  // Overall properties of the system\n    int N = X.n_cols-1;\n    int p = X.n_rows;\n\n  // Setup placeholder for difference process and deterministic trends\n    mat Z0 = zeros<mat>(p,N);\n    mat Psi_hat = zeros<mat>(p,1);\n\n  // Estimation using Least Squares, formula is: Psi_hat = T^-1*sum_{t=1}^T dX_t (this is px1 dimensional)\n    if(Psi){\n      // Estimate if given as TRUE\n      for(int n=0;n<N;n++){\n        Z0.col(n) = X.col(n+1)-X.col(n);\n        Psi_hat += Z0.col(n);\n      }\n      Psi_hat = Psi_hat/N;\n    } else{\n      for(int n=0;n<N;n++){\n        Z0.col(n) = X.col(n+1)-X.col(n);\n      }\n    }\n\n\n\n  // Calculate residuals and covariance estimator (see LÃ¼tkepohls book, p. 75)\n    mat res = zeros<mat>(p,N);\n    mat Omega = zeros<mat>(p,p);\n    for(int n=0;n<N;n++){\n      res.col(n) = Z0.col(n)-Psi_hat;\n      Omega += res.col(n)*res.col(n).t();\n    }\n    Omega = (Omega/N)*(N/(N-1));\n\n    // cout << \"res\" << endl;\n    // cout << res << endl;\n\n  // Calculate r-hypotheses statistics\n    int r_tmp = 1;\n    mat tmp = vecm(X,r_tmp, eye<mat>(p,p), eye<mat>(p,p), Psi, dt);\n    mat test  = tmp.cols(2*r_tmp+p+1,2*r_tmp+p+1);\n    mat eigs  = tmp.cols(2*r_tmp+p+2,2*r_tmp+p+2);\n    mat joha = join_rows(test,eigs);\n\n  // Model estimates\n    mat est = join_rows(Psi_hat/dt,Omega/dt);\n\n  // Add test statistics for r- hypotheses\n    mat est_test = join_rows(est,joha);\n\n  // Output estimates and residuals\n    mat out  = join_rows(est_test,res);\n\n  // Estimation using MLE is not implemented yet.\n\n  return out;\n}\n\n\n\n\n// [[Rcpp::export]]\narma::mat johansenCpp(arma::mat X, int r, arma::mat A, arma::mat B, bool Psi, double dt=1){\n// Johansen estimation procedure, returns parameter estimate, test statistics, eigenvalues and residuals\n\n  int N = X.n_cols-1;   // Number of observations\n  int p = X.n_rows;     // Dimension of the system\n\n  mat out = zeros<mat>(p,N);\n  if(r > 0){\n    out = vecm(X,r,A,B,Psi,dt);\n  } else{\n    out = var(X,Psi,dt);\n  }\n  return out;\n}\n",
    "created" : 1551097728772.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3959932248",
    "id" : "7C44098F",
    "lastKnownWriteTime" : 1551184509,
    "last_content_update" : 1551184509738,
    "path" : "~/Library/Mobile Documents/com~apple~CloudDocs/GitHub/Source/R/High-Dim Cointegration/HiDimCI/src/johansen.cpp",
    "project_path" : "src/johansen.cpp",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}